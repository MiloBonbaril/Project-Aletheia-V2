<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Project Aletheia Controller</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js" integrity="sha384-Sse/HDqcypGpyTDpvZOJNnG0TT3feGQUkF9H+mnRvic+LjR+K1NhTt8f51KIQ3v3" crossorigin="anonymous"></script>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        background-color: #0f172a;
        color: #e2e8f0;
      }

      header {
        padding: 1.5rem;
        background: linear-gradient(135deg, #1e293b, #0f172a);
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      header h1 {
        margin: 0 0 0.5rem 0;
        font-size: 1.75rem;
        font-weight: 600;
      }

      header p {
        margin: 0;
        color: #94a3b8;
      }

      main {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 1.5rem;
        padding: 1.5rem;
      }

      .status-bar {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem 1.5rem;
        background: #1e293b;
        border-bottom: 1px solid rgba(148, 163, 184, 0.1);
      }

      .status-label {
        font-weight: 500;
        color: #cbd5f5;
      }

      .status-chip {
        display: inline-flex;
        align-items: center;
        padding: 0.35rem 0.75rem;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 600;
        letter-spacing: 0.02em;
      }

      .status-chip--ok {
        background: rgba(34, 197, 94, 0.15);
        color: #4ade80;
      }

      .status-chip--alert {
        background: rgba(248, 113, 113, 0.2);
        color: #f87171;
      }

      .status-chip--warn {
        background: rgba(252, 211, 77, 0.15);
        color: #facc15;
      }

      .panel {
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.12);
        border-radius: 1rem;
        padding: 1.25rem;
        backdrop-filter: blur(6px);
        box-shadow: 0 20px 40px rgba(15, 23, 42, 0.35);
        display: flex;
        flex-direction: column;
        min-height: 360px;
      }

      .panel h2 {
        margin: 0 0 0.75rem 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: #e0e7ff;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
      }

      thead {
        text-transform: uppercase;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        color: #94a3b8;
      }

      th, td {
        padding: 0.5rem 0.65rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.08);
        vertical-align: top;
      }

      tbody tr:hover {
        background: rgba(148, 163, 184, 0.05);
      }

      .level {
        font-weight: 600;
      }

      .level--info {
        color: #60a5fa;
      }

      .level--warning {
        color: #facc15;
      }

      .level--error,
      .level--critical {
        color: #f87171;
      }

      .log-context {
        opacity: 0.7;
        font-size: 0.8rem;
        display: block;
        margin-top: 0.35rem;
        word-break: break-word;
      }

      canvas {
        width: 100%;
        height: 100%;
      }

      .chart-container {
        position: relative;
        flex: 1;
        min-height: 280px;
      }

      @media (max-width: 768px) {
        header h1 {
          font-size: 1.4rem;
        }

        main {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Project Aletheia Controller</h1>
      <p>Centralised observability for front/back services with live telemetry.</p>
    </header>

    <div class="status-bar">
      <span class="status-label">Emergency Stop:</span>
      <span id="stop-status" class="status-chip status-chip--ok">Idle</span>
      <span class="status-label">WebSocket:</span>
      <span id="ws-indicator" class="status-chip status-chip--warn">Connecting...</span>
    </div>

    <main>
      <section class="panel" style="grid-column: span 2; min-height: 420px;">
        <h2>Recent Logs</h2>
        <table id="logs-table">
          <thead>
            <tr>
              <th>Time</th>
              <th>Component</th>
              <th>Level</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>

      <section class="panel">
        <h2>DB Pool Metrics</h2>
        <div class="chart-container">
          <canvas id="dbChart" aria-label="Database pool utilisation"></canvas>
        </div>
      </section>

      <section class="panel">
        <h2>GPU Utilisation</h2>
        <div class="chart-container">
          <canvas id="gpuChart" aria-label="GPU utilisation over time"></canvas>
        </div>
      </section>
    </main>

    <script>
      const MAX_LOG_ROWS = 60;
      const MAX_POINTS = 60;

      const logsTableBody = document.querySelector('#logs-table tbody');
      const stopStatusEl = document.getElementById('stop-status');
      const wsIndicatorEl = document.getElementById('ws-indicator');

      const dbChart = new Chart(document.getElementById('dbChart').getContext('2d'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            { label: 'Checked Out', data: [], borderColor: '#f43f5e', tension: 0.2, fill: false },
            { label: 'Pool Size', data: [], borderColor: '#22d3ee', tension: 0.2, fill: false },
            { label: 'Overflow', data: [], borderColor: '#a855f7', tension: 0.2, fill: false },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: { color: '#cbd5f5' },
              grid: { color: 'rgba(148, 163, 184, 0.15)' },
            },
            x: {
              ticks: { color: '#94a3b8' },
              grid: { color: 'rgba(148, 163, 184, 0.08)' },
            },
          },
          plugins: {
            legend: {
              labels: { color: '#cbd5f5' },
            },
          },
        },
      });

      const gpuChart = new Chart(document.getElementById('gpuChart').getContext('2d'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            { label: 'GPU Util (%)', data: [], borderColor: '#fb923c', tension: 0.2, fill: false },
            { label: 'Mem Util (%)', data: [], borderColor: '#38bdf8', tension: 0.2, fill: false },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              ticks: { color: '#cbd5f5' },
              grid: { color: 'rgba(148, 163, 184, 0.15)' },
            },
            x: {
              ticks: { color: '#94a3b8' },
              grid: { color: 'rgba(148, 163, 184, 0.08)' },
            },
          },
          plugins: {
            legend: {
              labels: { color: '#cbd5f5' },
            },
          },
        },
      });

      function escapeHtml(value) {
        if (value === null || value === undefined) return '';
        return String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      function formatTime(iso) {
        if (!iso) return '';
        const date = new Date(iso);
        if (Number.isNaN(date.getTime())) return iso;
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      }

      function trimSeries(chart) {
        while (chart.data.labels.length > MAX_POINTS) {
          chart.data.labels.shift();
          chart.data.datasets.forEach((dataset) => dataset.data.shift());
        }
      }

      function pushSeriesPoint(chart, label, values) {
        chart.data.labels.push(label);
        chart.data.datasets.forEach((dataset, index) => {
          dataset.data.push(values[index] ?? null);
        });
        trimSeries(chart);
        chart.update('none');
      }

      function addLogRow(item) {
        if (!item) return;
        const row = document.createElement('tr');
        const levelClass = `level level--${(item.level || '').toLowerCase()}`;
        const contextText = item.context ? escapeHtml(JSON.stringify(item.context)) : '';
        row.innerHTML = `
          <td>${escapeHtml(formatTime(item.timestamp))}</td>
          <td>${escapeHtml(item.component || '')}</td>
          <td class="${levelClass}">${escapeHtml(item.level || '')}</td>
          <td>
            ${escapeHtml(item.message || '')}
            ${contextText ? `<span class="log-context">${contextText}</span>` : ''}
          </td>
        `;
        logsTableBody.prepend(row);
        while (logsTableBody.rows.length > MAX_LOG_ROWS) {
          logsTableBody.deleteRow(-1);
        }
      }

      function updateStopStatus(status) {
        if (!status) return;
        const active = Boolean(status.active);
        stopStatusEl.textContent = active ? 'ACTIVE' : 'Idle';
        stopStatusEl.classList.toggle('status-chip--alert', active);
        stopStatusEl.classList.toggle('status-chip--ok', !active);

        if (status.last_command) {
          const { initiator, reason, timestamp } = status.last_command;
          const details = [
            timestamp ? `At: ${formatTime(timestamp)}` : null,
            initiator ? `By: ${initiator}` : null,
            reason ? `Reason: ${reason}` : null,
          ]
            .filter(Boolean)
            .join(' \n');
          stopStatusEl.title = details || '';
        } else {
          stopStatusEl.title = '';
        }
      }

      function setWsIndicator(connected) {
        if (connected) {
          wsIndicatorEl.textContent = 'Connected';
          wsIndicatorEl.classList.remove('status-chip--warn');
          wsIndicatorEl.classList.add('status-chip--ok');
        } else {
          wsIndicatorEl.textContent = 'Disconnected';
          wsIndicatorEl.classList.remove('status-chip--ok');
          wsIndicatorEl.classList.add('status-chip--warn');
        }
      }

      function handleMetricSnapshot(item) {
        if (!item || !item.payload) return;
        const payload = item.payload;
        const label = formatTime(item.timestamp);

        if (payload.db && payload.db.pool) {
          const pool = payload.db.pool;
          const values = [
            typeof pool.checkedout === 'number' ? pool.checkedout : null,
            typeof pool.size === 'number' ? pool.size : null,
            typeof pool.overflow === 'number' ? pool.overflow : null,
          ];
          pushSeriesPoint(dbChart, label, values);
        }

        if (payload.gpu && Array.isArray(payload.gpu.gpus) && payload.gpu.gpus.length) {
          const gpu = payload.gpu.gpus[0];
          const values = [
            typeof gpu.utilization_gpu === 'number' ? gpu.utilization_gpu : null,
            typeof gpu.utilization_memory === 'number' ? gpu.utilization_memory : null,
          ];
          pushSeriesPoint(gpuChart, label, values);
        }
      }

      function primeSnapshot(snapshot) {
        if (!snapshot) return;
        if (Array.isArray(snapshot.logs)) {
          snapshot.logs.forEach((log) => addLogRow(log));
        }
        if (Array.isArray(snapshot.metrics)) {
          snapshot.metrics.forEach((metric) => handleMetricSnapshot(metric));
        }
        if (snapshot.stop_status) {
          updateStopStatus(snapshot.stop_status);
        }
      }

      function bootstrapWebSocket() {
        const scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const socket = new WebSocket(`${scheme}://${window.location.host}/ws/stream`);

        socket.addEventListener('open', () => setWsIndicator(true));
        socket.addEventListener('close', () => setWsIndicator(false));
        socket.addEventListener('error', () => setWsIndicator(false));

        socket.addEventListener('message', (event) => {
          try {
            const message = JSON.parse(event.data);
            switch (message.type) {
              case 'snapshot':
                primeSnapshot(message);
                break;
              case 'log':
                addLogRow(message.item);
                break;
              case 'metric':
                handleMetricSnapshot(message.item);
                break;
              case 'stop_status':
                updateStopStatus(message.item);
                break;
              default:
                break;
            }
          } catch (error) {
            console.error('Failed to process websocket message', error);
          }
        });

        return socket;
      }

      bootstrapWebSocket();
    </script>
  </body>
</html>




